✅ реализовать отдачу ошибок в функии ack на бекенде

✅ реализовать реагирование на ошибку в первом параметре ack функции на фронтенде

✅ обработать плохие серверные статусы в сторе

✅ реализовать на бекенде широковещательные события для обновления и удаления

✅ подключить vue-router

✅ подписка/отписка на бродкасты сущности должна происходить при хуках mount/unmount

✅ подключатся к socket-io серверу при криэйтеде корневого компонента

✅ разделить стору на модули и плагины

✅ установить jest на бекенде

✅ настроить первый example тест

✅ создать еще одну сущность на бекенде

✅ добавить эту сущность на фронтенд

✅ переделать html-css на vuetify чтоб было не настолько уродливо

✅ сверстать форму sign-up

✅ сверстать форму sign-in

✅ реализовать работу с аккаутнами регистрация/аутентификация/авторизация

✅ регистрация

✅ аутентификация

✅ добавить сущность сессий

✅ self-made

✅ POST /auth/sign-up
✅ POST /auth/sign-in

✅ реализовать работу с правами пользователей

✅ реализовать логику sign-in на фронтенде

✅ логинизация профиля на фронтенде

✅ раскатать приложение на локальном виртуальном тестовом сервере qemu/kvm

✅ рефакторинг фронтенда и бекенда

✅ рефакторинг фронтенда

✅ рефакторинг бекенда

✅ рефакторинг таблицы в удобные слоты (реализация TurboTable || TableSheet)

✅ рефакторинг формы в тупой компонент (реализация TurboForm)

✅ рефакторинг проверки ошибок в сторе на деструктуризацию в левую ошибку и правую дату

✅ вычислять заголовки таблицы по первому элементу массива плохая идея, потому что при появлении ошибки err в объекте элемента массива - в таблице появляется дополнительная лишняя колонка ERR и вся вёрстка таблицы съезжает из-за этого

✅ конвергенция компонентов форм

✅ перенести Widgets в Pages

отделить TurboSheet от TurboForm ?

✅ реализовать списки и аккаунтов и сессий на фронтенде (по http rest)

✅ функции updateById и removeById можно прокинуть из TurboTable в TurboTr так как эти функции работают с одной сущностью, и TurboTr какраз занимается ровно одной сущностью

реализовать мидлварю для авторизации через socket-io

описать бекенд интерфейсы для контроллеров, роутеров и сервисов

выделить специальный enum объект событий для socket-io с разделением на клиентские и серверные события SV и CL

рефакторинг псевдотаблиц и Orm в postgress и Type ORM

прописать миграции базы данных

база данных из dbml схемы

добавить Swagger

рефакторинг di контейнера в inversify-js

реализовать показывание онлайновости юзера

реализовать логирование бекенда через winston (уже реализовано в битстрейнере)

контейнеризация Docker

оркестрация Kubernetes K8s

фронтенд должен гарантированно подписыватся на бродкаст сущности только 1 раз
любая возможность двойной подписки на сущность должна быть запрещена
подписка на бродкасты при mutation.type === 'users/SET_USERS' плохая идея, потому что пользователь имеет кнопки для принудительного обновления(хотя зачем)
можно сделать отписку перед каждой подпиской

страница tests - говно. её нужно убрать

при создании сервера нужно установить это:
const io = new Server({serveClient: false})
потому что сервер хостит это: http://localhost:7704/socket.io/socket.io.js

необходимо реализовать проверку входящей функции ack

при добавлении новой сущности с ошибкой нужно не сбрасывать поля формы

реализоваать обработку ошибок и исключений

логирование ошибок винстоном

логирование дейcтвий винстоном

Service.add()
в репозиторий должны сохранятся модели, а не dto
точнее модель нужно конвертировать в запись
тоесть из dto нужно создать модель, а потом сконвертировать её в запись
а вот и нет. модель сущности может быть только у уже добавленной в репозиторий сущности.
не должно быть моделей, у которых нет записи в репозитории
и на выход должен уходить либо dto либо json
не нужно работающую модель выплёвывать в контроллер

AccountRepositoryDb.add()
поля, которые не пришли в dto база данных устанавливает по дефолту
пока временно буду делать дефолтные поля в маппере .toRecord()
хотя можно и в конструкторе, но лучше не надо

должны ли все сущности быть уникальными на всех ресурсах ? 409 статус при добавлении и обновлении ресурса должен быть на всех контроллерах ?

ВСЕ данные в контроллер приходят уже корректные и в правильном формате! поэтому их не нужно дополнительно проверять в контроллере. этими проверками занимается мидлваря

model/Profile:
время, прошедшее с момента регистрации
время, прошедшее с последнего изменения профайла
время, прошедшее с последней аутентификации
время, прошедшее с последней авторизации
находится ли онлайн в данный момент
список открытых сессий (ip адресс, устройство)

нужно настроить typescript на понимание алиаса @/ в импортах

валидация всех входных данных:
cookies
params
query
body

каждое поле имеет свою проверку
verifyField(fieldName, fieldData)

для каждого входа своя функция
verifyCookies
verifyParams
verifyQuery
verifyBody

все 4 функции можно будет скомпилировать в одну единую мидлварю
verifyEntrance

нужно разделить мидлвари на 2 вида
shared middlewares (ID, SESSID)
entity middlewares (ADD, UPD)

auth0/google

DELETE /auth/sign-out
POST /auth/change-password
POST /auth/profile
GET /auth/profile
DELETE /auth/wipe-out
DELETE /auth/wipe-proof
POST /auth/refresh
POST /auth/forgot-password
POST /auth/reset-password

при rest запросах сервис должен генерировать <BC-SV> событие и все клиенты обновляют данные на это событие. в отличие от <BC-CL> когда обнавляют все кроме клиента, который вещает.

в socket-io разделять id и data в update запросах и ответа довольно геморно.
помоему гораздо лучше присылать целиком dto и обновлять его в завимимости от сигнатуры метода. если это updateById то обновлять по data.id

да и вообще это разделение на id и data - один сплошной гемор, который вынужденно приходится поддерживать из-за rest http протокола
